5/03


In C ogni byte è associato ad una locazione di memoria, e ogni locazione
di memoria ha un suo indirizzo di 32 bit.

Questo indirizzo è rappresentato in notazione esadecimale:

    indirizzo   |   contenuto
    0xF0000000      00100010
    0xF0000001  |   00110001
        ...           ...   


la parte 0x serve a indicare che il resto è in esadecimale.

In generale quello che interessa non è il valore assoluto di un indirizzo,
ma la sua posizione relativa rispetto ad un altro indirizzo di riferimento,

quindi non capita di lavorare con i valori contenuti nelle variabili di indirizzo,
ma piuttosto con le variabili che contengono questi valori senza entrare nello
specifico dei valori contenuti.

Rappresentazioni:

 pt_i | 100 |     i (100) | contenuto di i |

 pt_i |_____| ----> i |______|

Ci basta sapere che pt_i contiene l'indirizzo di i, ma non quale sia nello specifico 
questo indirizzo.

Grazie all'operatore "&" prima di una variabile, viene restituita il valore dell'indirizzo
di quella variabile.

La sintassi di definizione di una variabile di tipo puntatore:
    
    [Tipo della variabile] *[nome puntatore];
    int *p1;

Analogamente alle altre dichiarazioni di variabili, la dichiarazione senza assegnazione da risultati
non predicibili quando viene utilizzata la variabile senza inizializzarla.


l'operatore *(argomento) usato non durante una dichiarazione può trovarsi a destra o sinistra di un'assegnazione.
In entrambi i casi il suo utilizzo serve a prendere in considerazione la locazione di memoria con indirizzo
equivalente al valore della variabile puntatore. quindi

    - A destra di un'assegnazione si considera il valore all'interno della locazione di memoria corrispondente
      all'indirizzo salvato nel puntatore.
    - A sinistra di un'assegnazione, assegna il valore a destra alla locazione di memoria puntata dall'indirizzo
        salvato nella variabile puntatore argomento di *

Ovviamente puntatori diversi possono fare riferimento alla stessa locazione di memoria

- Operatore " + " su variabile di tipo puntatore.

E' fondamentale il tipo di variabile a cui punta il puntatore, poichè nella somma, il valore sommato al puntatore
si moltiplica per i byte necessari per salvare in memoria la variabile a cui il puntatore punta:

    int a = 5;
    int* p = &a;
    int* q = p + 2;     // indirizzo di p + 2 * sizeof(int) poichè a è un int

la variabile puntatore q allora conterrà l'indirizzo della cella di memoria che sta 8 posizioni dopo quella
a cui stiamo sommando


